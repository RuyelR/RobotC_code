#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
void go_straight (float distance);
void rotate(float AOR);

float r = 0.032;
task main()
{
	//	motor[rightMotor] = 40;		  // Motor on port2 is run at full (127) power forward
	//	motor[leftMotor]  = 40;  // Motor on port3 is run at full (127) power forward
	//	wait1Msec(1000);		        // Robot runs previous code for 3000 milliseconds before moving on

	go_straight (0.30);
	rotate (PI/2.0);
}


void go_straight (float distance)
{

	float e = (180.0*distance)/(PI*r);

	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	//While less than 1000 encoder counts of the right motor
	while(abs(nMotorEncoder[rightMotor]) < e)
	{
		//Move forward at half power
		motor[rightMotor] = 60;
		motor[leftMotor]	= 60;

	}
	motor[rightMotor] = 0;
	motor[leftMotor]	= 0;

}


void rotate (float AOR)
{
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	if(AOR > 0)  //rotate counterclock   4.7 * AOR*180.0/PI
	{
		while(abs(nMotorEncoder[leftMotor]) < (5.55 * AOR*180.0/PI))
		{
			motor[rightMotor] = 50;
			motor[leftMotor]	= -50;
		}
	}
	else if (AOR < 0)  //rotate clockwise
	{
		while(abs(nMotorEncoder[rightMotor]) < 5.55 * abs(AOR)*180.0/PI)
		{
			motor[rightMotor] = -50;
			motor[leftMotor]	= 50;
		}
	}

	motor[rightMotor] = 0;
	motor[leftMotor]	= 0;
}
